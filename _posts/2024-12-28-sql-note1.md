---
layout: post
title: "Play with SQL Query (Basic&Intermediate)"
date: 2024-12-28 17:28:30 +0100
categories: SQL DATABASE
tags: adventure
---

üçã
---
Before writing any SQL (or indeed, any other language) query to retrieve data, the first step is to figure out the desired data.   
That's a broad topic that I won't talk about in this post üò£.   
However it's crucial to keep this mindset from the very beginning: know exactly what we want.  


üçá
---

# Navigation

  - [The Order Matter: SELECT comes after the others...](#the-order-matter-select-comes-after-the-others)
  - ["GROUP BY" Or "Window Function"?](#group-by-or-window-function)
  - [Deal With Complex String: Regular Expression Functions](#deal-with-complex-string-regular-expression-functions)
- [**Reference**](#reference)


üçí
---

# The Order Matter: SELECT comes after the others... {#the-order-matter-select-comes-after-the-others}


This section will be focusing on the order of execution for SQL commands.   

A common basic SQL query typically follows this structures:
```SQL
SELECT *
FROM table
WHERE ...
GROUP BY ...
HAVING ...
ORDER BY ...;
```
  
The computer process this query in the following order:
1. **FROM**: Access the specific **table**;
2. **WHERE**: Apply filters to retrieve relevant **rows**;
3. **GROUP BY**: Group the **rows** retrieved in step 2;
4. **HAVING**: Apply filters to the **groups of rows** formed in step 3;
5. ***SELECT***: Decide which **columns** will be retrieved;
6. **ORDER BY**: order the **retrieved data**.

Notably, the SELECT command is executed **after** WHERE, GROUP BY, and HAVING.   
  
Therefore, when advanced queries are involved in the SELECT command, such as [Window Functions](#group-by-or-window-function), they are only applied **after** the WHERE, GROUP BY, and HAVING commands have been processed.   
That is, **we cannot filter table based on columns generated by Window Functions we involved in the SELECT section.**

Generally, **to achieve this, we have to create a table using Common Table Expression(CTE) to storage the new columns created.** We can then filter data based on them.    

This advanced SQL query with **CTE** will follow this structures:
```SQL
-- start with the CTE command
WITH new_table AS ( 
    SELECT 
        *,
        DENSE_RANK() OVER (PARTITION BY a ORDER BY b) as rn -- window function
    FROM
        table
)
SELECT *
FROM new_table
WHERE rn = 1 -- filter based on rn created by window function
GROUP BY ...
HAVING ...
ORDER BY ...;
```

ü••
---
# "GROUP BY" Or "Window Function"? {#group-by-or-window-function} 

Window functions:
1. **can not** be involved in: WHERE, GROUP BY, and HAVING.
2. **can** be involved in: SELECT, ORDER BY.
 



üçâ
---
# Deal With Complex String: Regular Expression Functions {#deal-with-complex-string-regular-expression-functions}

Love it‚ô•Ô∏è‚ô•Ô∏è‚ô•Ô∏è.  
They are super powerful in dealing with complex string.   

## Regex:
1. **can not** be involved in: None.
2. **can** be involved in: SELECT,WHERE, GROUP BY, HAVING, ORDER BY.   

## Parameter: 
The default parameter is 'c', which means the match will be case-sensitive. 'China' will not match 'china'.  
Parameters should be determined when you do your search of matches:
| Parameter | Description                           |
|-----------|---------------------------------------|
| c         | Case-sensitive matching               |
| i         | Case-insensitive matching             |
| m         | Multi-line mode                       |
| e         | Extract submatches                    |

## Character:
We use character to create the **patterns** we want to search for matches.   
Want to master this? Check this [Regular-Expressions](https://www.regular-expressions.info/tutorial.html) website.

Some commonly used characters:
| Character | Description                    |
|-----------|--------------------------------|
| ^         | match the starting position    |
| $         | match the ending position      |
| .         | match any single character     |
| *         | match the preceding element zero or more times  |
| {m,n}     | match the preceding element at least m and not more than n times  |
| []        | match one character inside this bracket  |
| [^]       | match character not inside this bracket  |
| \n        | back reference, Matches what the nth marked subexpression matched  |

## Functions List: 

Below are some commonly used functions with example for illustration.

| Function | Description |
|----------|--------------------------------|
| REGEXP_LIKE(subject, patterns, position, params) | whether a string matches the pattern |
| REGEXP_COUNT(subject, patterns, position, params) | count the occurances of the matched string |
| REGEXP_SUBSTR(subject, patterns, position, occurance, params, group_num) | return the substring that matches |
| REGEXP_SUBSTR_ALL(subject, patterns, position, occurance, params, group_num) | return all substrings that match in an array |
| REGEXP_INSTR(subject, patterns, position, occurance, option, params, group_num) | return the position of the specified occurrence of the regular expression pattern in the string subject |
| REGEXP_REPLACE(subject, patterns, replacement, position, occurance, option, params) | return the subject with the specified pattern (or all occurrences of the pattern) either removed or replaced by a replacement string | 




2. **Split a column with string** in the form of "a,b,c,d,e" or anything like that:
    ```SQL
    SELECT
        *,
        regexp_split_to_table(column_to_split, ',') AS split_column
        -- column_to_split: replace with the column you want to split
        -- ',': replace with the delimiter used in the column
    FROM
        table
    ```








üçì
---
# Reference
[snowflake: SQL Documentation](https://docs.snowflake.com/en/reference)

[w3resource: mySQL REGEXP Function](https://www.w3resource.com/mysql/string-functions/mysql-regexp-function.php)